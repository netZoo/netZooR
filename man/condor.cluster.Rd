% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/condor.cluster.R
\name{condor.cluster}
\alias{condor.cluster}
\title{Main clustering function for condor.}
\usage{
condor.cluster(condor.object, cs.method = "LCS", project = TRUE,
  low.memory = FALSE, deltaQmin = "default")
}
\arguments{
\item{condor.object}{Output of make.condor.object. This function uses 
\code{condor.object$edges}}

\item{cs.method}{is a string to specify which unipartite community 
structure algorithm should be used for the seed clustering. 
Options are \code{LCS} (\code{\link[igraph]{multilevel.community}}), 
\code{LEC} (\code{\link[igraph]{leading.eigenvector.community}}), 
\code{FG} (\code{\link[igraph]{fastgreedy.community}}).}

\item{project}{Provides options for initial seeding of the bipartite 
modularity maximization.
If TRUE, the nodes in the first column of \code{condor.object$edges}
are projected and clustered using \code{cs.method}. If FALSE, the 
complete bipartite network is clustered using the unipartite clustering 
methods listed in \code{cs.method}.}

\item{low.memory}{If TRUE, uses \code{\link{condor.modularity.max}}
instead of \code{\link{condor.matrix.modularity}}. This is a slower
implementation of the modularity maximization, which does not store any
matrices in memory. Useful on a machine with low RAM. However, runtimes
are (much) longer.}

\item{deltaQmin}{convergence parameter determining the minimum required increase
in the modularity for each iteration. Default is min(10^{-4},1/(number of edges)),
with number of edges determined by \code{nrow(condor.object$edges)}. User can
set this parameter by passing a numeric value to deltaQmin.}
}
\value{
\code{condor.object} with \code{\link{condor.modularity.max}} output
included.
}
\description{
This function performs community structure clustering using
the bipartite modularity described in
\code{\link{condor.modularity.max}}. This function uses a standard
(non-bipartite) community structure clustering of the uni-partite,
weighted projection of the original bipartite graph as an initial
guess for the bipartite modularity.
}
\examples{
r = c(1,1,1,2,2,2,3,3,3,4,4);
b = c(1,2,3,1,2,4,2,3,4,3,4);
reds <- c("Alice","Sue","Janine","Mary")
blues <- c("Bob","John","Ed","Hank")
elist <- data.frame(red=reds[r],blue=blues[b])
condor.object <- create.condor.object(elist)
condor.object <- condor.cluster(condor.object)
}

